# 字节码
1. 最多支持256个操作码，目前使用200左右。
2. 包含栈操作指令，包括与局部变量交互的指令；程序流程控制指令；对象操作指令，包括方法调用指令；算术运算以及类型转换指令。
3. 常用命令：javac 编译，javap -c 查看字节码

# 类加载器
## 类加载过程
1. 加载（Loading）：找 Class 文件
2. 验证（Verification）：验证格式、依赖
3. 准备（Preparation）：静态字段、方法表
4. 解析（Resolution）：符号解析为引用
5. 初始化（Initialization）：构造器、静态变
量赋值、静态代码块
6. 使用（Using）
7. 卸载（Unloading）
## 三类加载器
1. 启动类加载器（BootstrapClassLoader）
2. 扩展类加载器（ExtClassLoader）
3. 应用类加载器（AppClassLoader）

# JVM
## 常用启动参数
1. 打印日志（JDK8）：-Xloggc:gc.demo.log（日志保存路径） -XX:+PrintGCDetails（打印详细信息） -XX:+PrintGCDateStamps（打印时间戳）
2. 默认GC线程数：8核以下默认是核心数，8核以上是5/8+3。-XX:ParallelGCThreads=n
## 常用命令
1. 使用jps/jinfo 拿到java pid，然后使用jstat查看JVM内部gc相关信息，使用jmap 查看heap或类占用空间统计。
2. 如果出现线程死锁，可以使用jstack查看线程信息
3. jcmd执行 JVM 相关分析命令，是个整合命令。
## JDK内置工具
1. jconsole，jvisualvm，jmc可以图形化查看内存、线程、类、VM概要。
2. idea可以使用VisualGC插件。

# GC相关
1. java9之后默认GC算法是G1 GC. java8及之前是Parallel GC。
## 选择合适的GC算法
选择正确的 GC 算法，唯一可行的方式就是去尝试，一般性的指导原则：
1. 如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC；
2. 如果系统考虑低延迟有限，每次 GC 时间尽量短，用 CMS GC；
3. 如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC。
对于内存大小的考量：
1. 一般 4G 以上，算是比较大，用 G1 的性价比较高。
2. 一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC。
## 分配速率和提升速率
1. 分配速率表示单位时间分配的内存量。
2. 提升速率用于衡量单位时间内从年轻代提升到老年代的数据量。
## 解决分配速率过高和过早提升
1. 可以尝试增加年轻代大小。
2. 优化业务代码，减少批处理数据量大小。
## 常见问题
1. 程序里面的对象都还有引用，回收为什么会减少？因为本地方法执行完就释放。
2. CMS并发GC线程数默认占CPU1/4的线程
3. 解决死锁的两种方式①限制执行时间，超时 ②强制杀死其中一个
4. xss默认线程内存1M，降低xss可以增加可执行的线程数
5. 数据库连接池设置为50-100比500-1000性能更好
6. 调用方法需要把方法和参数都入栈，所以线程栈深度跟参数一致
7. JVM启动参数有600多个
8. 设置Xmx考虑非堆和堆外用多少