# 锁
## 什么是锁
* 为什么要有锁？更灵活，可以由程序来控制。
* Lock的性能比synchronized高吗？1.8的版本两者性能已经差不多，但是因为lock更灵活，所以如果需要灵活的场景还是需要lock。
* 什么是可重入锁？同一个线程第二个能否进入。
* 什么是公平锁？公平锁像队列，先进先出。非公平锁随机。
## 用锁最佳实践
1. 永远只在更新对象的成员变量时加锁
2. 永远只在访问可变的成员变量时加锁
3. 永远不在调用其他对象的方法时加锁
* 最小使用锁
    1. 降低锁范围：锁定代码的范围/作用域
    2. 细分锁粒度：讲一个大锁，拆分成多个小锁

## 并发原子类
1. 核心实现原理：volatile保证内存可见，CAS乐观锁自旋重试写入保证操作原子性。
2. LongAdder 对 AtomicLong 的改进：通过分段思想改进原子类，类比G1 GC、数据库分库分表

## 并发工具类
* 多个线程之间怎么协作？wait、notify，lock、condition。

# 集合类
## 原生类型
boolean、char、byte、short、int、long、float、double、void、Array